# الگوریتم‌ها

تصور کنید هر دنباله‌ای از دستورالعمل‌های ساده که کاری انجام دهد را الگوریتم بنامیم. به عبارت دقیق‌تر، دنباله‌ای خوش‌تعریف از دستورات که **ورودی(ها)** را به **خروجی(ها)** تبدیل کنند را الگوریتم می‌نامیم. با این تعریف، دستور طبخ یک غذا که مواد اولیه (**ورودی‌ها**) را به غذای مورد نظر(**خروجی**)
 تبدیل می‌کند یا برنامه‌ای که اعداد کوچکتر از ۱۰۰ را روی صفحه نمایش چاپ می‌کند (**ورودی:** ندارد، **خروجی:** چاپ اعداد) را می‌توان الگوریتم نامید. بیایید به مثال برنامه کامپیوتری بپردازیم. شما این برنامه را چگونه پیاده‌سازی می‌کنید؟ یک پیاده‌سازی به زبان سطح بالای پایتون می‌تواند مطابق ذیل باشد.

``` python
   for i in range(1,101):
       print(i)
```

اگر بخواهیم برنامه‌ای بنویسیم که اعداد ۱ تا n را چاپ کند چطور؟ (**ورودی:** مقدار n **خروجی:** چاپ اعداد ۱ تا n) تابع زیر این کار را انجام می‌دهد.

``` python
   def print_nums(n):
       for i in range(1,n+1):
           print(i)
```

در حقیقت، توانستیم **الگوریتمی** ارائه دهیم که اعداد ۱ تا n را روی صفحه چاپ کند.
فرض کنید که ما هر دو کد را روی یک سیستم یکسان اجرا می‌کنیم. ما در مورد زمانی که طول می‌کشد یک دستور ساده (مانند جمع یا انتساب) در این سیستم اجرا شود اطلاعی نداریم. اما می‌دانیم که اگر دستور انتساب به اندازه ``$` t_{انتساب} `$`` طول بکشد، با تکرار اجرای الگوریتم، زمان اجرای دستور انتساب تغییر نخواهد کرد.
با این فرض می‌توانیم زمان اجرای کد اول را محاسبه کنیم:

``` math
   T_{اولی} = t_{range} + 100 \times (t_{انتساب}+t_{print})
```

حالا اگر بخواهیم در مورد زمان اجرای کد دوم اظهار نظر کنیم چه می‌توانیم بگوییم؟

``` math
   T_{دومی}{(n)} = t_{range} + n \times (t_{انتساب}+t_{print})
```

``` warning:: دستور for نوشته‌شده به زبان پایتون، در واقع ساختار متفاوتی با سایر زبان‌ها مانند سی و جاوا دارد. در اینجا مقدار i یکی یکی زیاد نمی‌شود، بلکه هر بار مقدار جدیدی به i منتسب می‌شود. به همین دلیل ۱۰۰ بار عمل انتساب انجام می‌شود. همچنین فرض بر این است که زمان اجرای توابع print و range مستقل از ورودی هستند.
```

نکته حائز اهمیت در اینجا این است که زمان اجرای کد دوم بر خلاف کد اول، مقدار ثابتی ندارد و **تابعی** از ورودی است. اما چنین موضوعی چه اهمیتی برای ما، به عنوان **طراحان الگوریتم** دارد؟ ابتدا اجازه دهید در مورد اهمیت زمان اجرای الگوریتم‌ها گپی بزنیم.

``` important:: در دنیای کامپیوتر (و شاید تمام جهان!) **فضا** و **زمان** مهم‌ترین ارکان هستند. همواره در تلاشیم که مقدار کمی از آن‌ها را مصرف کنیم! طراحی الگوریتم‌ها نیز از این قاعده مستثنی نیست، در اینجا هم می‌کوشیم حتی‌المقدور، الگوریتمی ارائه دهیم که زمان اجرای آن ‌کوتاه و فضای مصرفی آن اندک باشد. به همین دلیل لازم است در مورد فضای مصرفی و زمان اجرای الگوریتم‌ها بحث کنیم و بتوانیم الگوریتم‌های مختلف که برای یک مسأله ارائه شدند را بسنجیم و با هم مقایسه کنیم تا بتوانیم میان آن‌ها تصمیم‌گیری کنیم. سعی می‌کنیم راه حلی عمومی را معرفی می‌کنیم که با کمک آن، هم بتوان زمان اجرا و هم فضای مصرفی را مقایسه کرد.
```

برگردیم به کدها. اگر بخواهیم زمان اجرای دو کد گفته شده را با یکدیگر مقایسه کنیم، می‌توانیم به این شکل تحلیل کنیم که اگر **ورودی** در کد دوم، کمتر از ۱۰۰ باشد، آنگاه سرعت کد دوم بیشتر است و زمان اجرای کمتری دارد. اگر **ورودی** در کد دوم برابر با ۱۰۰ باشد، زمان‌های اجرا یکسان هستند و اگر **ورودی** در کد دوم بیش از ۱۰۰ باشد، زمان اجرای کد دوم بیشتر از کد اول خواهد بود.

| اندازه ورودی | کد سریع‌تر |
| ------------ | --------- |
| کمتر از ۱۰۰  | کد دوم    |
| ۱۰۰          | برابر     |
| بیش از ۱۰۰   | کد اول    |

اگر بخواهیم نظر نهایی را صادر کنیم، آیا می‌شود گفت که کد دوم سریعتر از کد اول است یا کندتر از آن؟ آیا راهی وجود دارد که بتوانیم یک نظر کلی دهیم؟ یعنی در مقایسه دو کد (یا الگوریتم) بتوان با قاطعیت گفت که یا زمان اجرای برابری دارند یا زمان یکی از دیگری بیشتر است.
پاسخ **مثبت** است. در واقع برای مقایسه زمان اجرای دو الگوریتم، لازم است که توابع زمان‌های اجراهای دو الگوریتم را با یکدیگر مقایسه کنیم. یعنی اگر بتوانیم یک روش قیاس برای توابع ارائه دهیم، آنگاه مقایسه زمان اجرای دو الگوریتم (و فضای مصرفی آن‌ها) کار دشواری نخواهد بود.
